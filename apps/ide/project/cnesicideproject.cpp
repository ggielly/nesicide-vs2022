#include "cnesicideproject.h"

#include "symbolwatchdockwidget.h"
#include "breakpointdockwidget.h"
#include "executionvisualizerdockwidget.h"

#include "nes_emulator_core.h"
#include "c64_emulator_core.h"
#include "cdockwidgetregistry.h"
#include "cbuildertextlogger.h"
#include "cgamedatabasehandler.h"

#define PROJECT_HEADER_FILE "project_data.h"
#define PROJECT_SOURCE_FILE "project_data.s"

#define NESICIDE_HEADER "; This file is automatically generated by NESICIDE.\n" \
                        "; DO NOT EDIT\n\n"

CNesicideProject* CNesicideProject::_instance = nullptr;

CNesicideProject::CNesicideProject()
{
	// Add node to tree as root
	InitTreeItem(":/resources/folder_closed.png");

	// Allocate children
	m_pProject = new CProject(this);
	m_pCartridge = new CCartridge(this);

	m_isInitialized = false;
	m_isDirty = false;

	m_projectTitle = "(No project loaded)";
	m_projectAddOns.clear();
	setProjectOutputBasePath(".");
	setProjectOutputName("");
	m_projectHeaderFileName = PROJECT_HEADER_FILE;
	m_projectSourceFileName = PROJECT_SOURCE_FILE;
	m_projectUsesCHRROM = true;
}

CNesicideProject::~CNesicideProject()
{
	if (m_pProject)
	{
		delete m_pProject;
	}
	if (m_pCartridge)
	{
		delete m_pCartridge;
	}
}

void CNesicideProject::initializeProject()
{
	QString cc65home = qgetenv("CC65_HOME");
	QDir dir = m_projectOutputBasePath;

	// Initialize this node's attributes
	m_projectPaletteEntries.clear();
	m_sourceSearchPaths.clear();
	m_projectAddOns.clear();

	// Palette is target-dependent!
	if (!m_projectTarget.compare("nes", Qt::CaseInsensitive))
	{
		for (int col = 0; col < nesGetNumColors(); col++)
		{
			m_projectPaletteEntries.append(QColor(nesGetPaletteRedComponent(col),
			                                      nesGetPaletteGreenComponent(col),
			                                      nesGetPaletteBlueComponent(col)));
		}

		// Add default expected source search paths that are target-dependent.
		// Doing it here to prevent users with pre-existing projects from having
		// to add the paths manually.
		addSourceSearchPath(QDir::fromNativeSeparators(cc65home + "/libsrc/nes"));
	}
	else if (!m_projectTarget.compare("c64", Qt::CaseInsensitive))
	{
		for (int col = 0; col < c64_get_num_colors(); col++)
		{
			m_projectPaletteEntries.append(QColor(c64GetPaletteRedComponent(col),
			                                      c64GetPaletteGreenComponent(col),
			                                      c64GetPaletteBlueComponent(col)));
		}

		// Add default expected source search paths that are target-dependent.
		// Doing it here to prevent users with pre-existing projects from having
		// to add the paths manually.
		addSourceSearchPath(QDir::fromNativeSeparators(cc65home + "/libsrc/c64"));
	}

	// Add default expected source search paths that are target-independent.
	// Doing it here to prevent users with pre-existing projects from having
	// to add the paths manually.
	addSourceSearchPath(QDir::fromNativeSeparators(cc65home + "/libsrc"));

	// Notify the fact that the project data has been initialized properly
	m_projectFileName = "(unset)";
	m_projectTitle = "(No project loaded)";
	setProjectOutputBasePath(".");
	setProjectOutputName("");
	m_projectHeaderFileName = PROJECT_HEADER_FILE;
	m_projectSourceFileName = PROJECT_SOURCE_FILE;
	m_compilerDefinedSymbols = "";
	m_compilerIncludePaths = "";
	m_compilerAdditionalOptions = "";
	m_assemblerDefinedSymbols = "";
	m_assemblerIncludePaths = "";
	m_assemblerAdditionalOptions = "";
	m_linkerConfigFile = "";
	m_makefileCustomRuleFiles.clear();
	m_linkerAdditionalOptions = "";
	m_linkerAdditionalDependencies = "";

	m_saveStateDoc.clear();

	m_tileProperties.clear();

	m_isInitialized = true;
	m_isDirty = false;

	// Initialize child nodes
	m_pProject->initializeProject();
	m_pCartridge->initializeProject();

	// Add child nodes to tree
	appendChild(m_pProject);
	appendChild(m_pCartridge);
}

void CNesicideProject::terminateProject()
{
	CBreakpointInfo* pBreakpoints;
	CMarker* pMarkers;
	int idx;

	// Clear out existing breakpoints...
	if (!m_projectTarget.compare("nes", Qt::CaseInsensitive))
	{
		pBreakpoints = nesGetBreakpointDatabase();
		if ((pBreakpoints) && (pBreakpoints->GetNumBreakpoints()))
		{
			for (idx = pBreakpoints->GetNumBreakpoints() - 1; idx >= 0; idx--)
			{
				pBreakpoints->RemoveBreakpoint(idx);
			}
		}
	}
	else if (!m_projectTarget.compare("c64", Qt::CaseInsensitive))
	{
		pBreakpoints = c64GetBreakpointDatabase();
		if (pBreakpoints->GetNumBreakpoints())
		{
			for (idx = pBreakpoints->GetNumBreakpoints() - 1; idx >= 0; idx--)
			{
				pBreakpoints->RemoveBreakpoint(idx);
			}
		}
	}

	// Terminate child nodes
	m_pProject->terminateProject();
	m_pCartridge->terminateProject();

	// Remove child nodes from tree
	removeChild(m_pCartridge);
	removeChild(m_pProject);

	// Notify the fact that the project data is no longer valid
	m_projectFileName = "(unset)";
	m_projectTitle = "(No project loaded)";
	m_projectAddOns.clear();
	setProjectOutputBasePath(".");
	setProjectOutputName("");
	m_projectHeaderFileName = PROJECT_HEADER_FILE;
	m_projectSourceFileName = PROJECT_SOURCE_FILE;
	m_compilerDefinedSymbols = "";
	m_compilerIncludePaths = "";
	m_compilerAdditionalOptions = "";
	m_assemblerDefinedSymbols = "";
	m_assemblerIncludePaths = "";
	m_assemblerAdditionalOptions = "";
	m_linkerConfigFile = "";
	m_makefileCustomRuleFiles.clear();
	m_linkerAdditionalOptions = "";
	m_linkerAdditionalDependencies = "";
	m_sourceSearchPaths.clear();

	m_saveStateDoc.clear();

	m_tileProperties.clear();

	m_isInitialized = false;
	m_isDirty = false;
}

bool CNesicideProject::serialize(QDomDocument& doc, QDomNode& node)
{
	// Create a DOM element to define the node this object represents, and add it to the
	// parent node assigned in from the caller.
	QDomElement projectElement = addElement(doc, node, "nesicideproject");

	// Set some variables as tags to this node.
	projectElement.setAttribute("version", "0.4");
	projectElement.setAttribute("target", m_projectTarget);
	projectElement.setAttribute("title", m_projectTitle);
	projectElement.setAttribute("addon-uris", m_projectAddOns.join(","));

	// Create the project configuration node.
	QDomElement propertiesElement = addElement(doc, projectElement, "properties");

	propertiesElement.setAttribute("outputbasepath", m_projectOutputBasePath);
	propertiesElement.setAttribute("linkeroutputbasepath", m_projectLinkerOutputBasePath);
	propertiesElement.setAttribute("linkeroutputname", m_projectLinkerOutputName);
	propertiesElement.setAttribute("debuginfoname", m_projectDebugInfoName);
	propertiesElement.setAttribute("compilerdefinedsymbols", m_compilerDefinedSymbols);
	propertiesElement.setAttribute("compilerincludepaths", m_compilerIncludePaths);
	propertiesElement.setAttribute("compileradditionaloptions", m_compilerAdditionalOptions);
	propertiesElement.setAttribute("assemblerdefinedsymbols", m_assemblerDefinedSymbols);
	propertiesElement.setAttribute("assemblerincludepaths", m_assemblerIncludePaths);
	propertiesElement.setAttribute("assembleradditionaloptions", m_assemblerAdditionalOptions);
	propertiesElement.setAttribute("linkerconfigfile", m_linkerConfigFile);
	propertiesElement.setAttribute("customrulefiles", m_makefileCustomRuleFiles.join(","));
	propertiesElement.setAttribute("linkeradditionaloptions", m_linkerAdditionalOptions);
	propertiesElement.setAttribute("linkeradditionaldependencies", m_linkerAdditionalDependencies);
	propertiesElement.setAttribute("sourcesearchpaths", m_sourceSearchPaths.join(";"));

	// These are NES-specific properties.
	if (!m_projectTarget.compare("nes", Qt::CaseInsensitive))
	{
		propertiesElement.setAttribute("outputname", m_projectOutputName);
		propertiesElement.setAttribute("headerfilename", m_projectHeaderFileName);
		propertiesElement.setAttribute("sourcefilename", m_projectSourceFileName);
		propertiesElement.setAttribute("chrromoutputbasepath", m_projectCHRROMOutputBasePath);
		propertiesElement.setAttribute("chrromoutputname", m_projectCHRROMOutputName);
		propertiesElement.setAttribute("chrrom", m_projectUsesCHRROM);
		propertiesElement.setAttribute("cartridgeoutputname", m_projectCartridgeOutputName);
		propertiesElement.setAttribute("cartridgesavestatename", m_projectCartridgeSaveStateName);
	}

	// These are NES-specific properties.
	if (!m_projectTarget.compare("nes", Qt::CaseInsensitive))
	{
		QDomElement tilePropertiesElement = addElement(doc, propertiesElement, "tileproperties");

		foreach(PropertyItem item, m_tileProperties)
		{
			QDomElement elm = addElement(doc, tilePropertiesElement, "property");
			elm.setAttribute("name", item.name);
			elm.setAttribute("type", item.type);
			elm.setAttribute("value", item.value);
		}
	}

	QDomElement inspectorsElement = addElement(doc, projectElement, "inspectors");

	// These are target-independent inspectors.
	auto pSymbolInspector = dynamic_cast<SymbolWatchDockWidget*>(CDockWidgetRegistry::instance()->getWidget(
		"Symbol Inspector"));
	pSymbolInspector->serialize(doc, inspectorsElement);

	auto pBreakpointInspector = dynamic_cast<BreakpointDockWidget*>(CDockWidgetRegistry::instance()->
		getWidget("Breakpoints"));
	pBreakpointInspector->serialize(doc, inspectorsElement);

	// This is a NES-specific inspector.  So it may not be part of the current UI.
	auto pExecutionVisualizer = dynamic_cast<ExecutionVisualizerDockWidget*>(CDockWidgetRegistry::instance()->getWidget(
		"Execution Visualizer"));
	if (pExecutionVisualizer)
	{
		pExecutionVisualizer->serialize(doc, inspectorsElement);
	}

	// Create the root palette element, and give it a version attribute
	QDomElement rootPaletteElement = addElement(doc, propertiesElement, "palette");

	// Loop through all palette entries, and for each entry add an <entry /> tag that has the
	// index, as well as the RGB properties of the palette.
	// Palette is target-dependent!
	if (!m_projectTarget.compare("nes", Qt::CaseInsensitive))
	{
		for (int indexOfCurrentPaletteEntry = 0; indexOfCurrentPaletteEntry < nesGetNumColors();
		     indexOfCurrentPaletteEntry++)
		{
			QDomElement elm = addElement(doc, rootPaletteElement, "entry");
			elm.setAttribute("index", indexOfCurrentPaletteEntry);
			elm.setAttribute("r", m_projectPaletteEntries.at(indexOfCurrentPaletteEntry).red());
			elm.setAttribute("g", m_projectPaletteEntries.at(indexOfCurrentPaletteEntry).green());
			elm.setAttribute("b", m_projectPaletteEntries.at(indexOfCurrentPaletteEntry).blue());
		}
	}
	else if (!m_projectTarget.compare("c64", Qt::CaseInsensitive))
	{
		for (int indexOfCurrentPaletteEntry = 0; indexOfCurrentPaletteEntry < c64_get_num_colors();
		     indexOfCurrentPaletteEntry++)
		{
			QDomElement elm = addElement(doc, rootPaletteElement, "entry");
			elm.setAttribute("index", indexOfCurrentPaletteEntry);
			elm.setAttribute("r", m_projectPaletteEntries.at(indexOfCurrentPaletteEntry).red());
			elm.setAttribute("g", m_projectPaletteEntries.at(indexOfCurrentPaletteEntry).green());
			elm.setAttribute("b", m_projectPaletteEntries.at(indexOfCurrentPaletteEntry).blue());
		}
	}

	// Now serialize all child objects.
	// This is a NES-specific project item.
	if (!m_projectTarget.compare("nes", Qt::CaseInsensitive))
	{
		if (!m_pCartridge->serialize(doc, projectElement))
		{
			return false;
		}
	}

	if (!m_pProject->serialize(doc, projectElement))
	{
		return false;
	}

	return true;
}

bool CNesicideProject::deserialize(QDomDocument& doc, QDomNode& /*node*/, QString& errors)
{
	// Read in the DOM element
	QDomElement projectElement = doc.documentElement();
	int numColors = 0;
	QString projectVersion;
	QString customRuleFileAttribute;

	m_isInitialized = false;

	if (projectElement.isNull())
	{
		return false;
	}

	// Project versioning for backward compatibility...
	projectVersion = projectElement.attribute("version", "");
	if (!(projectVersion == "0.4" ||
		projectVersion == "0.3"))
	{
		errors.append("NESICIDE Project file version is incorrect.\n");
		return false;
	}

	// Project versioning control.
	// Version 0.3->0.4 switched customrulefile property to customrulesfile (multiple custom rule files).
	if (projectVersion == "0.3")
	{
		customRuleFileAttribute = "customrulesfile";
	}
	else
	{
		customRuleFileAttribute = "customrulefiles";
	}

	// For now, error out if the target is not specified in the XML.
	if (projectElement.attribute("target").isEmpty())
	{
		errors.append("Missing required attribute 'target' of element <nesicideproject>\n");
		return false;
	}

	// Load the project target.
	m_projectTarget = projectElement.attribute("target");
	emit createTarget(m_projectTarget);

	// Load our properties. Note that the default value is returned if an attribute is missing.
	// This is the expected behavior.
	m_projectTitle = projectElement.attribute("title", "Untitled");

	m_projectAddOns = projectElement.attribute("addon-uris").split(",", QString::SkipEmptyParts);

	// Initialize the palette.
	if (!m_projectTarget.compare("nes", Qt::CaseInsensitive))
	{
		for (int color = 0; color < nesGetNumColors(); color++)
		{
			m_projectPaletteEntries.append(QColor(nesGetPaletteRedComponent(color),
			                                      nesGetPaletteGreenComponent(color),
			                                      nesGetPaletteBlueComponent(color)));
		}
	}
	else if (!m_projectTarget.compare("c64", Qt::CaseInsensitive))
	{
		for (int color = 0; color < c64_get_num_colors(); color++)
		{
			m_projectPaletteEntries.append(QColor(c64GetPaletteRedComponent(color),
			                                      c64GetPaletteGreenComponent(color),
			                                      c64GetPaletteBlueComponent(color)));
		}
	}

	// Now loop through the child elements and process the ones we find
	QDomNode child = projectElement.firstChild();

	do
	{
		if (child.nodeName() == "inspectors")
		{
			auto pSymbolInspector = dynamic_cast<SymbolWatchDockWidget*>(CDockWidgetRegistry::instance()->getWidget(
				"Symbol Inspector"));
			pSymbolInspector->deserialize(doc, child, errors);

			auto pBreakpointInspector = dynamic_cast<BreakpointDockWidget*>(CDockWidgetRegistry::instance()->getWidget(
				"Breakpoints"));
			pBreakpointInspector->deserialize(doc, child, errors);

			// This is a NES-specific inspector.  So it may not be part of the current UI.
			auto pExecutionVisualizer = dynamic_cast<ExecutionVisualizerDockWidget*>(CDockWidgetRegistry::instance()->
				getWidget("Execution Visualizer"));
			if (pExecutionVisualizer)
			{
				pExecutionVisualizer->deserialize(doc, child, errors);
			}
		}
		else if (child.nodeName() == "properties")
		{
			// Get the properties that are just attributes of the main node.
			QDomElement propertiesElement = child.toElement();

			m_projectOutputBasePath = propertiesElement.attribute("outputbasepath");
			m_projectLinkerOutputBasePath = propertiesElement.attribute("linkeroutputbasepath");
			m_projectLinkerOutputName = propertiesElement.attribute("linkeroutputname");
			m_projectDebugInfoName = propertiesElement.attribute("debuginfoname");
			m_compilerDefinedSymbols = propertiesElement.attribute("compilerdefinedsymbols");
			m_compilerIncludePaths = propertiesElement.attribute("compilerincludepaths");
			m_compilerAdditionalOptions = propertiesElement.attribute("compileradditionaloptions");
			m_assemblerDefinedSymbols = propertiesElement.attribute("assemblerdefinedsymbols");
			m_assemblerIncludePaths = propertiesElement.attribute("assemblerincludepaths");
			m_assemblerAdditionalOptions = propertiesElement.attribute("assembleradditionaloptions");
			m_linkerConfigFile = propertiesElement.attribute("linkerconfigfile");
			m_makefileCustomRuleFiles = propertiesElement.attribute(customRuleFileAttribute, "").split(
				",", QString::SkipEmptyParts);
			m_makefileCustomRuleFiles.removeDuplicates();
			m_linkerAdditionalOptions = propertiesElement.attribute("linkeradditionaloptions");
			m_linkerAdditionalDependencies = propertiesElement.attribute("linkeradditionaldependencies");
			m_sourceSearchPaths = propertiesElement.attribute("sourcesearchpaths", "").split(
				";", QString::SkipEmptyParts);
			m_sourceSearchPaths.removeDuplicates();
			m_projectOutputName = propertiesElement.attribute("outputname");

			// These are NES-specific parameters.
			if (!m_projectTarget.compare("nes", Qt::CaseInsensitive))
			{
				m_projectHeaderFileName = propertiesElement.attribute("headerfilename",PROJECT_HEADER_FILE);
				m_projectSourceFileName = propertiesElement.attribute("sourcefilename",PROJECT_SOURCE_FILE);
				m_projectCHRROMOutputBasePath = propertiesElement.attribute("chrromoutputbasepath");
				m_projectCHRROMOutputName = propertiesElement.attribute("chrromoutputname");
				m_projectUsesCHRROM = propertiesElement.attribute("chrrom").toInt();
				m_projectCartridgeOutputName = propertiesElement.attribute("cartridgeoutputname");
				m_projectCartridgeSaveStateName = propertiesElement.attribute("cartridgesavestatename");
			}

			// Loop through the properties nodes.
			QDomNode property = child.firstChild();
			do
			{
				if (!property.isNull())
				{
					// These are NES-specific project items.
					if (!m_projectTarget.compare("nes", Qt::CaseInsensitive))
					{
						if (property.nodeName() == "tileproperties")
						{
							// Get the properties that are attributes of the tileproperties node.
							QDomElement tilePropertiesElement = property.toElement();

							QDomNode tilePropertyNode = property.firstChild();
							do
							{
								QDomElement tilePropertyItem = tilePropertyNode.toElement();

								if (!tilePropertyItem.isNull())
								{
									if ((!tilePropertyItem.hasAttribute("name"))
										|| (!tilePropertyItem.hasAttribute("type"))
										|| (!tilePropertyItem.hasAttribute("value")))
									{
										errors.append("Error parsing <tileproperties> element.\n");
										return false;
									}

									PropertyItem item;
									item.name = tilePropertyItem.attribute("name");
									item.type = (propertyTypeEnum)tilePropertyItem.attribute("type").toInt();
									item.value = tilePropertyItem.attribute("value");
									m_tileProperties.append(item);
								}
							}
							while (!(tilePropertyNode = tilePropertyNode.nextSibling()).isNull());
						}
					}
					if (property.nodeName() == "palette")
					{
						// Palette is target-dependent!
						if (!m_projectTarget.compare("nes", Qt::CaseInsensitive))
						{
							numColors = nesGetNumColors();
						}
						else if (!m_projectTarget.compare("c64", Qt::CaseInsensitive))
						{
							numColors = c64_get_num_colors();
						}

						QDomNode paletteNode = property.firstChild();
						do
						{
							QDomElement paletteItem = paletteNode.toElement();

							if (paletteItem.isNull())
							{
								return false;
							}

							if ((!paletteItem.hasAttribute("index"))
								|| (!paletteItem.hasAttribute("r"))
								|| (!paletteItem.hasAttribute("g"))
								|| (!paletteItem.hasAttribute("b")))
							{
								errors.append("Error parsing <nesicidepalette> element.\n");
								return false;
							}

							int nodeIndex = paletteItem.attribute("index").toInt();

							if ((nodeIndex >= 0) && (nodeIndex < numColors))
							{
								m_projectPaletteEntries.replace(nodeIndex,
								                                QColor(paletteItem.attribute("r").toInt(),
								                                       paletteItem.attribute("g").toInt(),
								                                       paletteItem.attribute("b").toInt()));
							}
						}
						while (!(paletteNode = paletteNode.nextSibling()).isNull());
					}
				}
			}
			while (!(property = property.nextSibling()).isNull());
		}
		else if (child.nodeName() == "cartridge")
		{
			if (!m_projectTarget.compare("nes", Qt::CaseInsensitive))
			{
				if (!m_pCartridge->deserialize(doc, child, errors))
				{
					return false;
				}
			}
		}
		else if (child.nodeName() == "project")
		{
			if (!m_pProject->deserialize(doc, child, errors))
			{
				return false;
			}
		}
	}
	while (!(child = child.nextSibling()).isNull());

	m_isInitialized = true;
	return true;
}

QString CNesicideProject::caption() const
{
	return QString("NESICIDE");
}

void CNesicideProject::addSourceSearchPath(QString value)
{
	m_sourceSearchPaths.append(value);
	m_sourceSearchPaths.removeDuplicates();
}

void CNesicideProject::removeSourceSearchPath(QString value)
{
	m_sourceSearchPaths.removeAll(value);
}

bool CNesicideProject::createProjectFromRom(QString fileName, bool silent)
{
	CCHRROMBanks* chrRomBanks = getCartridge()->getChrRomBanks();
	CPRGROMBanks* prgRomBanks = getCartridge()->getPrgRomBanks();
	int oldBanks;
	int bankIdx;
	QString str;

	QFile fileIn(fileName);

	if (fileIn.exists() && fileIn.open(QIODevice::ReadOnly))
	{
		QDataStream fs(&fileIn);

		// Check the NES header
		char nesHeader[4] = {'N', 'E', 'S', 0x1A};
		char nesTest[4] = {0, 0, 0, 0};
		fs.readRawData(nesTest, 4);

		if (memcmp(nesHeader, nesTest, 4))
		{
			// Header check failed, quit
			fileIn.close();
			if (!silent)
			{
				QMessageBox::information(nullptr, "Error", "Invalid ROM format.\nCannot create project.");
			}
			return false;
		}

		// Number of 16 KB PRG-ROM banks
		qint8 numPrgRomBanks;
		fs >> numPrgRomBanks;

		// Convert to 8 KB banks
		numPrgRomBanks <<= 1;

		// Get the number of 8 KB CHR-ROM / VROM banks
		qint8 numChrRomBanks;
		fs >> numChrRomBanks;

		// ROM Control Byte 1:
		// - Bit 0 - Indicates the type of mirroring used by the game
		//   where 0 indicates horizontal mirroring, 1 indicates
		//   vertical mirroring.
		//
		// - Bit 1 - Indicates the presence of battery-backed RAM at
		//   memory locations $6000-$7FFF.
		//
		// - Bit 2 - Indicates the presence of a 512-byte trainer at
		//   memory locations $7000-$71FF.
		//
		// - Bit 3 - If this bit is set it overrides bit 0 to indicate fourscreen
		//   mirroring should be used.
		//
		// - Bits 4-7 - Four lower bits of the mapper number.
		qint8 romCB1;
		fs >> romCB1;

		// First extract the mirror mode
		if ((romCB1 & FLAG_MIRROR) == FLAG_MIRROR_VERT)
		{
			m_pCartridge->setMirrorMode(VerticalMirroring);
		}
		else
		{
			m_pCartridge->setMirrorMode(HorizontalMirroring);
		}
		if ((romCB1 & FLAG_VRAM) == FLAG_FOURSCREEN_VRAM)
		{
			m_pCartridge->setFourScreen(true);
		}

		// Now extract the two flags (battery backed ram and trainer)
		m_pCartridge->setBatteryBackedRam(romCB1 & 0x02);
		bool hasTrainer = (romCB1 & 0x04);

		// ROM Control Byte 2:
		//  Bits 0-3 - Reserved for future usage and should all be 0.
		//  Bits 4-7 - Four upper bits of the mapper number.
		qint8 romCB2;
		fs >> romCB2;

		if (romCB2 & 0x0F)
		{
			romCB2 = 0x00;
			if (!silent)
			{
				QMessageBox::information(nullptr, "Warning", "Invalid iNES header format.\nSave the project to fix.");
			}
		}

		// Extract the upper four bits of the mapper number
		m_pCartridge->setMapperNumber(((romCB1 >> 4) & 0x0F) | (romCB2 & 0xF0));

		// Number of 8 KB RAM banks. For compatibility with previous
		// versions of the iNES format, assume 1 page of RAM when
		// this is 0.
		qint8 numRamBanks;
		fs >> numRamBanks;

		if (numRamBanks == 0)
		{
			numRamBanks = 1;
		}

		// Skip the 7 reserved bytes
		qint8 skip;

		for (int i = 0; i < 7; i++)
		{
			fs >> skip;
		}

		// Extract the trainer (if it exists)
		if (hasTrainer)
		{
			// TODO: Handle trainer. Skipping for now.
			for (int i = 0; i < 512; i++)
			{
				fs >> skip;
			}
		}

		// Load the PRG-ROM banks (8KB each)
		oldBanks = prgRomBanks->getPrgRomBanks().count();
		bankIdx = 0;
		for (int bank = 0; bank < numPrgRomBanks; bank++)
		{
			// Grab either a previously used bank, or a new one
			CPRGROMBank* curBank;
			bool doAppend = (--oldBanks < 0);

			// Initialize the bank into the project banks
			if (doAppend)
			{
				curBank = new CPRGROMBank(CNesicideProject::instance()->getCartridge()->getPrgRomBanks());
				// This is a new bank
				curBank->setBankIndex(prgRomBanks->getPrgRomBanks().count());
				prgRomBanks->appendChild(curBank);
				prgRomBanks->getPrgRomBanks().append(curBank);
			}
			else
			{
				curBank = prgRomBanks->getPrgRomBanks().at(bankIdx++);
			}

			fs.readRawData((char*)curBank->getBankData(),MEM_8KB);
		}

		// Load the CHR-ROM banks (8KB each)
		oldBanks = chrRomBanks->getChrRomBanks().count();
		bankIdx = 0;
		for (int bank = 0; bank < numChrRomBanks; bank++)
		{
			// Grab either a previously used bank, or a new one
			CCHRROMBank* curBank;
			bool doAppend = (--oldBanks < 0);

			// Initialize the bank into the project banks
			if (doAppend)
			{
				curBank = new CCHRROMBank(CNesicideProject::instance()->getCartridge()->getChrRomBanks());
				// This is a new bank
				curBank->setBankIndex(chrRomBanks->getChrRomBanks().count());
				chrRomBanks->appendChild(curBank);
				chrRomBanks->getChrRomBanks().append(curBank);
			}
			else
			{
				curBank = chrRomBanks->getChrRomBanks().at(bankIdx++);
			}

			fs.readRawData((char*)curBank->getBankData(),MEM_8KB);
		}

		str = "<b>Searcing internal game database: ";
		str += CGameDatabaseHandler::instance()->getGameDBAuthor();
		str += ", ";
		str += CGameDatabaseHandler::instance()->getGameDBTimestamp();
		str += "...</b>";
		generalTextLogger->write(str);
		str = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
		str += fileName;
		generalTextLogger->write(str);

		bool gameFoundInDB = CGameDatabaseHandler::instance()->find(m_pCartridge);

		if (gameFoundInDB)
		{
			str = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHA1: ";
			str += CGameDatabaseHandler::instance()->getSHA1();
			generalTextLogger->write(str);

			str = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name: ";
			str += CGameDatabaseHandler::instance()->getName();
			generalTextLogger->write(str);

			str = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Publisher (date): ";
			str += CGameDatabaseHandler::instance()->getPublisher();
			str += " (";
			str += CGameDatabaseHandler::instance()->getDate();
			str += ")";
			generalTextLogger->write(str);

			// Set project title...
			if (!silent)
			{
				m_projectTitle = CGameDatabaseHandler::instance()->getName();
			}

			// Do NTSC/PAL autodetecting

			// Check cartridge validity?
		}
		else
		{
			str = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i><font color=\"red\">Not found.</font></i>";
			generalTextLogger->write(str);
		}

		str = "<b>Game loaded.</b>";
		generalTextLogger->write(str);

		fileIn.close();

		return true;
	}

	return false;
}

bool CNesicideProject::createRomFromProject(QString fileName)
{
	CCHRROMBanks* chrRomBanks = getCartridge()->getChrRomBanks();
	CPRGROMBanks* prgRomBanks = getCartridge()->getPrgRomBanks();

	QFile fileOut(fileName);

	if (fileOut.open(QIODevice::ReadWrite | QIODevice::Truncate))
	{
		QDataStream fs(&fileOut);

		// Check the NES header
		char nesHeader[4] = {'N', 'E', 'S', 0x1A};
		fs.writeRawData(nesHeader, 4);

		// Number of 16KB PRG-ROM banks
		qint8 numPrgRomBanks = prgRomBanks->getPrgRomBanks().count();

		// iNES header expects 16KB banks
		qint8 numPrgRomBanksHdr = numPrgRomBanks >> 1;

		fs << numPrgRomBanksHdr;

		// Get the number of 8KB CHR-ROM / VROM banks
		qint8 numChrRomBanks = chrRomBanks->getChrRomBanks().count();
		fs << numChrRomBanks;

		// ROM Control Byte 1:
		// - Bit 0 - Indicates the type of mirroring used by the game
		//   where 0 indicates horizontal mirroring, 1 indicates
		//   vertical mirroring.
		//
		// - Bit 1 - Indicates the presence of battery-backed RAM at
		//   memory locations $6000-$7FFF.
		//
		// - Bit 2 - Indicates the presence of a 512-byte trainer at
		//   memory locations $7000-$71FF.
		//
		// - Bit 3 - If this bit is set it overrides bit 0 to indicate fourscreen
		//   mirroring should be used.
		//
		// - Bits 4-7 - Four lower bits of the mapper number.
		qint8 romCB1 = 0x00;

		// First extract the mirror mode
		if (m_pCartridge->getMirrorMode() == VerticalMirroring)
		{
			romCB1 |= FLAG_MIRROR_VERT;
		}
		if (m_pCartridge->isBatteryBackedRam())
		{
			romCB1 |= 0x02;
		}
		romCB1 |= ((m_pCartridge->getMapperNumber() & 0xF) << 4);

		fs << romCB1;

		// ROM Control Byte 2:
		//  Bits 0-3 - Reserved for future usage and should all be 0.
		//  Bits 4-7 - Four upper bits of the mapper number.
		qint8 romCB2 = 0x00;

		romCB2 |= (m_pCartridge->getMapperNumber() & 0xF0);

		fs << romCB2;

		// Skip the 7 reserved bytes
		qint8 skip = 0;

		for (int i = 0; i < 8; i++)
		{
			fs << skip;
		}

		// Ignore trainer.

		// Save the PRG-ROM banks (16KB each)
		for (int bank = 0; bank < numPrgRomBanks; bank++)
		{
			// Grab either a previously used bank, or a new one
			CPRGROMBank* curBank = prgRomBanks->getPrgRomBanks().at(bank);

			fs.writeRawData((char*)curBank->getBankData(),MEM_8KB);
		}

		// Save the CHR-ROM banks (8KB each)
		for (int bank = 0; bank < numChrRomBanks; bank++)
		{
			// Grab either a previously used bank, or a new one
			CCHRROMBank* curBank = chrRomBanks->getChrRomBanks().at(bank);

			fs.writeRawData((char*)curBank->getBankData(),MEM_8KB);
		}

		fileOut.close();

		return true;
	}

	return false;
}

bool CNesicideProject::exportData()
{
	QDir dir(QDir::currentPath());
	QString projHdrFileName = dir.fromNativeSeparators(
		dir.relativeFilePath(CNesicideProject::instance()->getProjectHeaderFileName()));
	QFile projHdrFile(projHdrFileName);
	QList<PropertyEnumItem> items;
	bool ok = false;

	// This function exports project-specific data such as property enumerations
	// declared in the Project Properties panel.
	if (projHdrFile.open(QIODevice::ReadWrite | QIODevice::Text | QIODevice::Truncate))
	{
		projHdrFile.write(NESICIDE_HEADER);

		foreach(PropertyItem propertyItem, m_tileProperties)
		{
			if (propertyItem.type == propertyEnumeration)
			{
				projHdrFile.write(".enum ");
				projHdrFile.write(propertyItem.name.toLatin1());
				projHdrFile.write("\n");

				items = getEnumItems(propertyItem.value);
				foreach(PropertyEnumItem enumItem, items)
				{
					projHdrFile.write("\t");
					projHdrFile.write(enumItem.symbol.toLatin1());
					projHdrFile.write(" = ");
					projHdrFile.write(enumItem.value.toLatin1());
					projHdrFile.write("\n");
				}

				projHdrFile.write(".endenum\n\n");
			}
		}

		ok = true;

		projHdrFile.close();
	}

	return ok;
}

QString CNesicideProject::getMakefileCustomRules(QString rulesFile)
{
	QDir dir(QDir::currentPath());
	QString rules;

	if (!rulesFile.isEmpty())
	{
		QFile fileIn(dir.filePath(rulesFile));

		if (fileIn.exists())
		{
			fileIn.open(QIODevice::ReadOnly | QIODevice::Text);
			if (fileIn.isOpen())
			{
				rules = fileIn.readAll();
				fileIn.close();
			}
			else
			{
				QMessageBox::critical(nullptr, "File I/O Error", "Could not read custom rules file:\n" + rulesFile);
			}
		}
	}

	return rules;
}
